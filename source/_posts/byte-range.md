---
title: 为什么 byte 的范围是 -128~127?
date: 2019-01-06 21:06:42
tags: Java
toc: true
---

这是一个很基础的问题。但是在昨天之前，我都是只知其然，不知其所以然。

于是我搜索了大量网络资料。说实话，看完大部分文章，我还是没有弄明白为什么。直到我看到了知乎上面的一个回答：

[在8位二进制中，-128 没有原码、反码形式，那么它的补码是怎么计算出来的？还是约定的？](https://www.zhihu.com/question/20458542) ，醍醐灌顶。

这里尝试自己阐述一遍，如果你没有看懂，那是我的问题，还是直接看参考链接。

首先，忘记原码、补码、反码的概念。

从 「**模**」开始。什么是模?

想象日常见到的时钟，它可以表示 0 - 12 点的时间。假设当前时针指向 8 点，而准确时间是 5 点。那么调整方法有两种：

一种方法是将逆时针拨 3 小时，8 - 3 = 5。

另一种方法是顺时针拨 9 小时，8 + 9 = 12 + 5 = 5。

可以看出，减 3 和加 9 的效果是一样的，这里的 12 就是模，3 和 9 在模 12 中互为补数，也就是相加等于模的大小。

所以，在模的范围内做减法，可以将 X - Y 的减法等价于 X + Y 的补数。

但是新的问题又出现了，这种算法的结果永远是正数。

比如 3 - 8 = 3 + (12 - 8) = 7，实际上 3 - 8 = -5。很明显，7 不等于 -5 的。

怎么办呢，当初那些先贤想出来很简单的方法，就是把两个数直接划等号，正好解决了负数的表达方式。-5 的绝对值的补数正好是 7。

但是，又出现了新的问题，7 已经用来表示正数 7 了，现在又来表示 -5，当 7  出现时就很难辨别它到底代表谁了。

为了保留这套规则，只能牺牲 7 了，确定 7 只代表 -5。所以给这套规则划定一个范围，原来 0 - 11 的正数，拆分为两部分，0 - 5 这个区间代表正数，6 - 11 这个区间就用来代表各自的补数的负值。

回到二进制的计算机世界。

我们知道 byte 占用 8 位，一共可以表示 2 的 8 次方，256 个数，即 0 ~ 255。模是 256。

按照上面的规则， 0 - 127 代表其正数本身，128 - 255 代表其补数的负值，也就是 “-1 ~ - 128"。

所以，byte 的表示范围就是 -128 ~ 127 了。

总结下：

1、计算机中负值的表达方式就是它绝对值的补数。

2、这样表达的方式是为了实现数值运算而决定的。

3、几乎所有的课本和老师都只给出结论，没有给出解释原理的做法真是简直了。