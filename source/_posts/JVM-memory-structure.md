---
title: JVM内存结构
date: 2019-01-10 14:59:11
tags: JVM
toc: true
---

Java 虚拟机在执行 Java 程序的过程中会把它管理的内存划分为若干个不同的数据区域。

![](https://raw.githubusercontent.com/zywudev/blog-source/master/image/java_memory_structure.png)

这些区域中，一些是线程私有的，一些是线程共享的。

**线程私有的**：程序计数器、虚拟机栈、本地方法栈

**线程共享的**：堆、方法区、直接内存

## 程序计数器

一块较小的内存空间，用于标记当前线程所执行字节码的行号。

Java 虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式实现，所以确定的时刻一个处理器只会执行一个线程中的指令。

为了线程切换后能恢复到正确的执行位置，每个线程都需要一个独立的程序计数器，用于记录线程所执行字节码指令的地址。

## 虚拟机栈

Java 虚拟机栈是由一个个帧栈组成。

每个方法执行时会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。

当方法调用时，栈帧入栈，方法结束时，栈帧出栈。

局部变量表的所需的内存空间在编译期间完成分配，运行时不会改变大小。

虚拟机栈定义了两种异常状况：StackOverFlowError  和  OutOfMemoryError 。

- StackOverFlowError：线程请求的栈深度大于虚拟机所允许的深度。
-  OutOfMemoryError ：大多数虚拟机都允许动态扩展虚拟机栈的大小，所以线程可以一直申请栈，直到内存不足时，抛出 OutOfMemoryError。

## 本地方法栈

本地方法栈为虚拟机使用到的 native 方法服务。

HotSpot 虚拟机直接把虚拟机栈与本地方法栈合二为一。与虚拟机栈一样，也会抛出 StackOverFlowError 和 OutOfMememoryError 异常。

## 堆

Java 堆是垃圾收集器管理的主要区域，也称为 GC 堆。所有实例和数组都在这里分配内存，也是线程共享的内存区域。

-Xms 设置最小值；-Xmx 设置最大值。

堆内存分配会另写一篇文章介绍。

## 方法区

与 Java 堆一样，也是线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。

在 HotSpot 虚拟机中，这块区域对应永久代，不易被回收。

**运行时常量池**：属于方法区一部分。用于存放编译期生成的常量和引用。

JDK 1.7 之后已经将运行时常量池从移出，在堆上开辟了一块区域存放运行时常量池。

## 直接内存

直接内存并不是虚拟机内存的一部分，也不是 Java 虚拟机规范中定义的内存区域。

jdk1.4 中新加入的 NIO，引入了通道与缓冲区的 IO 方式，它可以调用 Native 方法直接分配堆外内存，这个堆外内存就是本机内存，不会影响到堆内存的大小。

## 参考资料

[深入理解Java虚拟机:JVM高级特性与最佳实践(第2版)](https://book.douban.com/subject/24722612/)

